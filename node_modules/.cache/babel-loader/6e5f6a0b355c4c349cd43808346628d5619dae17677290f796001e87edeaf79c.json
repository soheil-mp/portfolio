{"ast":null,"code":"import{getBlogMetadata,getAllBlogSlugs}from'../utils/markdownParser';// Initialize blog posts asynchronously\nlet blogPosts=[];const initializeBlogPosts=async()=>{const slugs=getAllBlogSlugs();const posts=await Promise.all(slugs.map(slug=>getBlogMetadata(slug)));blogPosts=posts.filter(post=>post!==null);return blogPosts;};// Export a promise that resolves to the blog posts\nexport const getBlogPosts=async()=>{if(blogPosts.length===0){await initializeBlogPosts();}return blogPosts;};export const categories=[{name:\"Trading Strategies\",slug:\"trading-strategies\",count:2,description:\"Quantitative trading strategies and implementation guides\"},{name:\"Portfolio Theory\",slug:\"portfolio-theory\",count:1,description:\"Modern portfolio theory and optimization techniques\"},{name:\"Algorithm Development\",slug:\"algorithm-development\",count:1,description:\"Development and optimization of trading algorithms\"}];// Helper functions\nexport const getFeaturedPosts=async()=>{const posts=await getBlogPosts();return posts.filter(post=>post.featured);};export const getPostBySlug=async slug=>{const posts=await getBlogPosts();return posts.find(post=>post.slug===slug);};export const getPostsByCategory=async category=>{const posts=await getBlogPosts();return posts.filter(post=>post.category===category);};export const getAllTags=async()=>{const posts=await getBlogPosts();const tags=new Set();posts.forEach(post=>{if(post.tags){post.tags.forEach(tag=>tags.add(tag));}});return Array.from(tags);};","map":{"version":3,"names":["getBlogMetadata","getAllBlogSlugs","blogPosts","initializeBlogPosts","slugs","posts","Promise","all","map","slug","filter","post","getBlogPosts","length","categories","name","count","description","getFeaturedPosts","featured","getPostBySlug","find","getPostsByCategory","category","getAllTags","tags","Set","forEach","tag","add","Array","from"],"sources":["C:/Users/Soheil/Desktop/Codebase/GitHub/quant-blog/src/data/blogData.js"],"sourcesContent":["import { getBlogMetadata, getAllBlogSlugs } from '../utils/markdownParser';\r\n\r\n// Initialize blog posts asynchronously\r\nlet blogPosts = [];\r\n\r\nconst initializeBlogPosts = async () => {\r\n  const slugs = getAllBlogSlugs();\r\n  const posts = await Promise.all(slugs.map(slug => getBlogMetadata(slug)));\r\n  blogPosts = posts.filter(post => post !== null);\r\n  return blogPosts;\r\n};\r\n\r\n// Export a promise that resolves to the blog posts\r\nexport const getBlogPosts = async () => {\r\n  if (blogPosts.length === 0) {\r\n    await initializeBlogPosts();\r\n  }\r\n  return blogPosts;\r\n};\r\n\r\nexport const categories = [\r\n  {\r\n    name: \"Trading Strategies\",\r\n    slug: \"trading-strategies\",\r\n    count: 2,\r\n    description: \"Quantitative trading strategies and implementation guides\"\r\n  },\r\n  {\r\n    name: \"Portfolio Theory\",\r\n    slug: \"portfolio-theory\",\r\n    count: 1,\r\n    description: \"Modern portfolio theory and optimization techniques\"\r\n  },\r\n  {\r\n    name: \"Algorithm Development\",\r\n    slug: \"algorithm-development\",\r\n    count: 1,\r\n    description: \"Development and optimization of trading algorithms\"\r\n  }\r\n];\r\n\r\n// Helper functions\r\nexport const getFeaturedPosts = async () => {\r\n  const posts = await getBlogPosts();\r\n  return posts.filter(post => post.featured);\r\n};\r\n\r\nexport const getPostBySlug = async (slug) => {\r\n  const posts = await getBlogPosts();\r\n  return posts.find(post => post.slug === slug);\r\n};\r\n\r\nexport const getPostsByCategory = async (category) => {\r\n  const posts = await getBlogPosts();\r\n  return posts.filter(post => post.category === category);\r\n};\r\n\r\nexport const getAllTags = async () => {\r\n  const posts = await getBlogPosts();\r\n  const tags = new Set();\r\n  posts.forEach(post => {\r\n    if (post.tags) {\r\n      post.tags.forEach(tag => tags.add(tag));\r\n    }\r\n  });\r\n  return Array.from(tags);\r\n}; "],"mappings":"AAAA,OAASA,eAAe,CAAEC,eAAe,KAAQ,yBAAyB,CAE1E;AACA,GAAI,CAAAC,SAAS,CAAG,EAAE,CAElB,KAAM,CAAAC,mBAAmB,CAAG,KAAAA,CAAA,GAAY,CACtC,KAAM,CAAAC,KAAK,CAAGH,eAAe,CAAC,CAAC,CAC/B,KAAM,CAAAI,KAAK,CAAG,KAAM,CAAAC,OAAO,CAACC,GAAG,CAACH,KAAK,CAACI,GAAG,CAACC,IAAI,EAAIT,eAAe,CAACS,IAAI,CAAC,CAAC,CAAC,CACzEP,SAAS,CAAGG,KAAK,CAACK,MAAM,CAACC,IAAI,EAAIA,IAAI,GAAK,IAAI,CAAC,CAC/C,MAAO,CAAAT,SAAS,CAClB,CAAC,CAED;AACA,MAAO,MAAM,CAAAU,YAAY,CAAG,KAAAA,CAAA,GAAY,CACtC,GAAIV,SAAS,CAACW,MAAM,GAAK,CAAC,CAAE,CAC1B,KAAM,CAAAV,mBAAmB,CAAC,CAAC,CAC7B,CACA,MAAO,CAAAD,SAAS,CAClB,CAAC,CAED,MAAO,MAAM,CAAAY,UAAU,CAAG,CACxB,CACEC,IAAI,CAAE,oBAAoB,CAC1BN,IAAI,CAAE,oBAAoB,CAC1BO,KAAK,CAAE,CAAC,CACRC,WAAW,CAAE,2DACf,CAAC,CACD,CACEF,IAAI,CAAE,kBAAkB,CACxBN,IAAI,CAAE,kBAAkB,CACxBO,KAAK,CAAE,CAAC,CACRC,WAAW,CAAE,qDACf,CAAC,CACD,CACEF,IAAI,CAAE,uBAAuB,CAC7BN,IAAI,CAAE,uBAAuB,CAC7BO,KAAK,CAAE,CAAC,CACRC,WAAW,CAAE,oDACf,CAAC,CACF,CAED;AACA,MAAO,MAAM,CAAAC,gBAAgB,CAAG,KAAAA,CAAA,GAAY,CAC1C,KAAM,CAAAb,KAAK,CAAG,KAAM,CAAAO,YAAY,CAAC,CAAC,CAClC,MAAO,CAAAP,KAAK,CAACK,MAAM,CAACC,IAAI,EAAIA,IAAI,CAACQ,QAAQ,CAAC,CAC5C,CAAC,CAED,MAAO,MAAM,CAAAC,aAAa,CAAG,KAAO,CAAAX,IAAI,EAAK,CAC3C,KAAM,CAAAJ,KAAK,CAAG,KAAM,CAAAO,YAAY,CAAC,CAAC,CAClC,MAAO,CAAAP,KAAK,CAACgB,IAAI,CAACV,IAAI,EAAIA,IAAI,CAACF,IAAI,GAAKA,IAAI,CAAC,CAC/C,CAAC,CAED,MAAO,MAAM,CAAAa,kBAAkB,CAAG,KAAO,CAAAC,QAAQ,EAAK,CACpD,KAAM,CAAAlB,KAAK,CAAG,KAAM,CAAAO,YAAY,CAAC,CAAC,CAClC,MAAO,CAAAP,KAAK,CAACK,MAAM,CAACC,IAAI,EAAIA,IAAI,CAACY,QAAQ,GAAKA,QAAQ,CAAC,CACzD,CAAC,CAED,MAAO,MAAM,CAAAC,UAAU,CAAG,KAAAA,CAAA,GAAY,CACpC,KAAM,CAAAnB,KAAK,CAAG,KAAM,CAAAO,YAAY,CAAC,CAAC,CAClC,KAAM,CAAAa,IAAI,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACtBrB,KAAK,CAACsB,OAAO,CAAChB,IAAI,EAAI,CACpB,GAAIA,IAAI,CAACc,IAAI,CAAE,CACbd,IAAI,CAACc,IAAI,CAACE,OAAO,CAACC,GAAG,EAAIH,IAAI,CAACI,GAAG,CAACD,GAAG,CAAC,CAAC,CACzC,CACF,CAAC,CAAC,CACF,MAAO,CAAAE,KAAK,CAACC,IAAI,CAACN,IAAI,CAAC,CACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}