{"ast":null,"code":"import { getBlogMetadata, getAllBlogSlugs } from '../utils/markdownParser';\n\n// Initialize blog posts asynchronously\nlet blogPosts = [];\nconst initializeBlogPosts = async () => {\n  const slugs = getAllBlogSlugs();\n  const posts = await Promise.all(slugs.map(slug => getBlogMetadata(slug)));\n  blogPosts = posts.filter(post => post !== null);\n  return blogPosts;\n};\n\n// Export a promise that resolves to the blog posts\nexport const getBlogPosts = async () => {\n  if (blogPosts.length === 0) {\n    await initializeBlogPosts();\n  }\n  return blogPosts;\n};\nexport const categories = [{\n  name: \"Trading Strategies\",\n  slug: \"trading-strategies\",\n  count: 2,\n  description: \"Quantitative trading strategies and implementation guides\"\n}, {\n  name: \"Portfolio Theory\",\n  slug: \"portfolio-theory\",\n  count: 1,\n  description: \"Modern portfolio theory and optimization techniques\"\n}, {\n  name: \"Algorithm Development\",\n  slug: \"algorithm-development\",\n  count: 1,\n  description: \"Development and optimization of trading algorithms\"\n}];\n\n// Helper functions\nexport const getFeaturedPosts = async () => {\n  const posts = await getBlogPosts();\n  return posts.filter(post => post.featured);\n};\nexport const getPostBySlug = async slug => {\n  const posts = await getBlogPosts();\n  return posts.find(post => post.slug === slug);\n};\nexport const getPostsByCategory = async category => {\n  const posts = await getBlogPosts();\n  return posts.filter(post => post.category === category);\n};\nexport const getAllTags = async () => {\n  const posts = await getBlogPosts();\n  const tags = new Set();\n  posts.forEach(post => {\n    if (post.tags) {\n      post.tags.forEach(tag => tags.add(tag));\n    }\n  });\n  return Array.from(tags);\n};","map":{"version":3,"names":["getBlogMetadata","getAllBlogSlugs","blogPosts","initializeBlogPosts","slugs","posts","Promise","all","map","slug","filter","post","getBlogPosts","length","categories","name","count","description","getFeaturedPosts","featured","getPostBySlug","find","getPostsByCategory","category","getAllTags","tags","Set","forEach","tag","add","Array","from"],"sources":["C:/Users/Soheil/Desktop/Codebase/GitHub/quant-blog/src/data/blogData.js"],"sourcesContent":["import { getBlogMetadata, getAllBlogSlugs } from '../utils/markdownParser';\r\n\r\n// Initialize blog posts asynchronously\r\nlet blogPosts = [];\r\n\r\nconst initializeBlogPosts = async () => {\r\n  const slugs = getAllBlogSlugs();\r\n  const posts = await Promise.all(slugs.map(slug => getBlogMetadata(slug)));\r\n  blogPosts = posts.filter(post => post !== null);\r\n  return blogPosts;\r\n};\r\n\r\n// Export a promise that resolves to the blog posts\r\nexport const getBlogPosts = async () => {\r\n  if (blogPosts.length === 0) {\r\n    await initializeBlogPosts();\r\n  }\r\n  return blogPosts;\r\n};\r\n\r\nexport const categories = [\r\n  {\r\n    name: \"Trading Strategies\",\r\n    slug: \"trading-strategies\",\r\n    count: 2,\r\n    description: \"Quantitative trading strategies and implementation guides\"\r\n  },\r\n  {\r\n    name: \"Portfolio Theory\",\r\n    slug: \"portfolio-theory\",\r\n    count: 1,\r\n    description: \"Modern portfolio theory and optimization techniques\"\r\n  },\r\n  {\r\n    name: \"Algorithm Development\",\r\n    slug: \"algorithm-development\",\r\n    count: 1,\r\n    description: \"Development and optimization of trading algorithms\"\r\n  }\r\n];\r\n\r\n// Helper functions\r\nexport const getFeaturedPosts = async () => {\r\n  const posts = await getBlogPosts();\r\n  return posts.filter(post => post.featured);\r\n};\r\n\r\nexport const getPostBySlug = async (slug) => {\r\n  const posts = await getBlogPosts();\r\n  return posts.find(post => post.slug === slug);\r\n};\r\n\r\nexport const getPostsByCategory = async (category) => {\r\n  const posts = await getBlogPosts();\r\n  return posts.filter(post => post.category === category);\r\n};\r\n\r\nexport const getAllTags = async () => {\r\n  const posts = await getBlogPosts();\r\n  const tags = new Set();\r\n  posts.forEach(post => {\r\n    if (post.tags) {\r\n      post.tags.forEach(tag => tags.add(tag));\r\n    }\r\n  });\r\n  return Array.from(tags);\r\n}; "],"mappings":"AAAA,SAASA,eAAe,EAAEC,eAAe,QAAQ,yBAAyB;;AAE1E;AACA,IAAIC,SAAS,GAAG,EAAE;AAElB,MAAMC,mBAAmB,GAAG,MAAAA,CAAA,KAAY;EACtC,MAAMC,KAAK,GAAGH,eAAe,CAAC,CAAC;EAC/B,MAAMI,KAAK,GAAG,MAAMC,OAAO,CAACC,GAAG,CAACH,KAAK,CAACI,GAAG,CAACC,IAAI,IAAIT,eAAe,CAACS,IAAI,CAAC,CAAC,CAAC;EACzEP,SAAS,GAAGG,KAAK,CAACK,MAAM,CAACC,IAAI,IAAIA,IAAI,KAAK,IAAI,CAAC;EAC/C,OAAOT,SAAS;AAClB,CAAC;;AAED;AACA,OAAO,MAAMU,YAAY,GAAG,MAAAA,CAAA,KAAY;EACtC,IAAIV,SAAS,CAACW,MAAM,KAAK,CAAC,EAAE;IAC1B,MAAMV,mBAAmB,CAAC,CAAC;EAC7B;EACA,OAAOD,SAAS;AAClB,CAAC;AAED,OAAO,MAAMY,UAAU,GAAG,CACxB;EACEC,IAAI,EAAE,oBAAoB;EAC1BN,IAAI,EAAE,oBAAoB;EAC1BO,KAAK,EAAE,CAAC;EACRC,WAAW,EAAE;AACf,CAAC,EACD;EACEF,IAAI,EAAE,kBAAkB;EACxBN,IAAI,EAAE,kBAAkB;EACxBO,KAAK,EAAE,CAAC;EACRC,WAAW,EAAE;AACf,CAAC,EACD;EACEF,IAAI,EAAE,uBAAuB;EAC7BN,IAAI,EAAE,uBAAuB;EAC7BO,KAAK,EAAE,CAAC;EACRC,WAAW,EAAE;AACf,CAAC,CACF;;AAED;AACA,OAAO,MAAMC,gBAAgB,GAAG,MAAAA,CAAA,KAAY;EAC1C,MAAMb,KAAK,GAAG,MAAMO,YAAY,CAAC,CAAC;EAClC,OAAOP,KAAK,CAACK,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACQ,QAAQ,CAAC;AAC5C,CAAC;AAED,OAAO,MAAMC,aAAa,GAAG,MAAOX,IAAI,IAAK;EAC3C,MAAMJ,KAAK,GAAG,MAAMO,YAAY,CAAC,CAAC;EAClC,OAAOP,KAAK,CAACgB,IAAI,CAACV,IAAI,IAAIA,IAAI,CAACF,IAAI,KAAKA,IAAI,CAAC;AAC/C,CAAC;AAED,OAAO,MAAMa,kBAAkB,GAAG,MAAOC,QAAQ,IAAK;EACpD,MAAMlB,KAAK,GAAG,MAAMO,YAAY,CAAC,CAAC;EAClC,OAAOP,KAAK,CAACK,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACY,QAAQ,KAAKA,QAAQ,CAAC;AACzD,CAAC;AAED,OAAO,MAAMC,UAAU,GAAG,MAAAA,CAAA,KAAY;EACpC,MAAMnB,KAAK,GAAG,MAAMO,YAAY,CAAC,CAAC;EAClC,MAAMa,IAAI,GAAG,IAAIC,GAAG,CAAC,CAAC;EACtBrB,KAAK,CAACsB,OAAO,CAAChB,IAAI,IAAI;IACpB,IAAIA,IAAI,CAACc,IAAI,EAAE;MACbd,IAAI,CAACc,IAAI,CAACE,OAAO,CAACC,GAAG,IAAIH,IAAI,CAACI,GAAG,CAACD,GAAG,CAAC,CAAC;IACzC;EACF,CAAC,CAAC;EACF,OAAOE,KAAK,CAACC,IAAI,CAACN,IAAI,CAAC;AACzB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}