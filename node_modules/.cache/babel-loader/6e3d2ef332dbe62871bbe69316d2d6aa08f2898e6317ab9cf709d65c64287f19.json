{"ast":null,"code":"import { marked } from 'marked';\n\n// Configure marked options\nmarked.setOptions({\n  breaks: true,\n  gfm: true\n});\n\n// Parse frontmatter from markdown content\nconst parseFrontmatter = text => {\n  console.log('parseFrontmatter called with text length:', text.length);\n  console.log('First 200 chars:', text.substring(0, 200));\n  const lines = text.split('\\n');\n  console.log('Total lines:', lines.length);\n  console.log('First line:', JSON.stringify(lines[0]));\n  if (lines[0].trim() !== '---') {\n    console.log('No frontmatter detected - first line is not ---');\n    return {\n      data: {},\n      content: text\n    };\n  }\n  let frontmatterEnd = -1;\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i].trim() === '---') {\n      frontmatterEnd = i;\n      break;\n    }\n  }\n  console.log('Frontmatter end found at line:', frontmatterEnd);\n  if (frontmatterEnd === -1) {\n    console.log('No closing --- found');\n    return {\n      data: {},\n      content: text\n    };\n  }\n  const frontmatterLines = lines.slice(1, frontmatterEnd);\n  const content = lines.slice(frontmatterEnd + 1).join('\\n');\n  console.log('Frontmatter lines:', frontmatterLines);\n  console.log('Content after frontmatter (first 200 chars):', content.substring(0, 200));\n  const frontmatter = {};\n  let currentKey = null;\n  frontmatterLines.forEach((line, index) => {\n    const trimmedLine = line.trim();\n    console.log(`Processing line ${index}: \"${line}\" (trimmed: \"${trimmedLine}\")`);\n    if (trimmedLine.startsWith('-') && currentKey) {\n      // YAML array item\n      const value = trimmedLine.substring(1).trim();\n      console.log(`  Adding array item \"${value}\" to key \"${currentKey}\"`);\n      if (!Array.isArray(frontmatter[currentKey])) {\n        frontmatter[currentKey] = [];\n      }\n      frontmatter[currentKey].push(value);\n    } else if (trimmedLine.includes(':')) {\n      // Key-value pair\n      const [key, ...valueParts] = line.split(':');\n      const value = valueParts.join(':').trim();\n      currentKey = key.trim();\n      console.log(`  Found key-value: \"${currentKey}\" = \"${value}\"`);\n      if (value) {\n        // Handle JSON-style arrays [item1, item2]\n        if (value.startsWith('[') && value.endsWith(']')) {\n          try {\n            frontmatter[currentKey] = JSON.parse(value);\n            console.log(`    Parsed as JSON array:`, frontmatter[currentKey]);\n          } catch {\n            frontmatter[currentKey] = value.slice(1, -1).split(',').map(item => item.trim());\n            console.log(`    Parsed as simple array:`, frontmatter[currentKey]);\n          }\n        }\n        // Handle quoted strings\n        else if (value.startsWith('\"') && value.endsWith('\"') || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n          frontmatter[currentKey] = value.slice(1, -1);\n          console.log(`    Parsed as quoted string:`, frontmatter[currentKey]);\n        }\n        // Handle booleans\n        else if (value === 'true' || value === 'false') {\n          frontmatter[currentKey] = value === 'true';\n          console.log(`    Parsed as boolean:`, frontmatter[currentKey]);\n        }\n        // Handle regular strings\n        else {\n          frontmatter[currentKey] = value;\n          console.log(`    Parsed as string:`, frontmatter[currentKey]);\n        }\n      } else {\n        // Key without value - prepare for YAML array\n        frontmatter[currentKey] = [];\n        console.log(`    Initialized as empty array for YAML items`);\n      }\n    }\n  });\n  console.log('Final parsed frontmatter:', frontmatter);\n  console.log('Content length after parsing:', content.length);\n  return {\n    data: frontmatter,\n    content\n  };\n};\nexport const parseMarkdown = async markdownPath => {\n  try {\n    const response = await fetch(markdownPath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\n    }\n    const markdownText = await response.text();\n\n    // Parse frontmatter and content (content should already be stripped of frontmatter)\n    const {\n      data: frontmatter,\n      content\n    } = parseFrontmatter(markdownText);\n    console.log('parseMarkdown - Raw content length:', content.length);\n    console.log('parseMarkdown - Content preview:', content.substring(0, 200));\n\n    // Convert markdown to HTML\n    const htmlContent = marked(content);\n    return {\n      frontmatter,\n      content: htmlContent,\n      rawContent: content\n    };\n  } catch (error) {\n    console.error('Error parsing markdown:', error);\n    return null;\n  }\n};\n\n// Get all blog files from the /blogs directory\nexport const getAllBlogFiles = async () => {\n  try {\n    console.log('Starting blog discovery...');\n\n    // First, try to get directory listing\n    let blogFiles = [];\n    try {\n      const response = await fetch('/blogs');\n      if (response.ok) {\n        const html = await response.text();\n        console.log('Directory listing HTML length:', html.length);\n\n        // Extract .md file names from directory listing HTML\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(html, 'text/html');\n\n        // Try multiple selectors to find .md files\n        let links = doc.querySelectorAll('a[href$=\".md\"]');\n        if (links.length === 0) {\n          // Fallback: look for any links containing .md\n          links = doc.querySelectorAll('a[href*=\".md\"]');\n        }\n        if (links.length === 0) {\n          // Another fallback: look in the HTML text for .md files\n          const mdMatches = html.match(/[\\w-]+\\.md/g);\n          if (mdMatches) {\n            console.log('Found .md files via regex:', mdMatches);\n            for (const filename of mdMatches) {\n              await loadBlogFile(filename, blogFiles);\n            }\n          }\n        } else {\n          console.log('Found .md links via querySelector:', links.length);\n          for (const link of links) {\n            const filename = link.getAttribute('href');\n            if (filename && filename.endsWith('.md')) {\n              await loadBlogFile(filename, blogFiles);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Directory listing failed, trying fallback method:', error);\n    }\n\n    // Fallback: if no files found via directory listing, try known files\n    if (blogFiles.length === 0) {\n      console.log('No files found via directory listing, trying known files...');\n      const knownFiles = ['momentum-trading-strategies.md', 'portfolio-theory-optimization.md', 'breakout-trading-systems.md', 'rainbow-algorithm-analysis.md'];\n      for (const filename of knownFiles) {\n        await loadBlogFile(filename, blogFiles);\n      }\n    }\n    console.log('Total blog files processed:', blogFiles.length);\n\n    // Sort by date (newest first)\n    const sortedFiles = blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\n    console.log('Sorted blog files:', sortedFiles);\n    return sortedFiles;\n  } catch (error) {\n    console.error('Error getting blog files:', error);\n    return [];\n  }\n};\n\n// Helper function to load a single blog file\nconst loadBlogFile = async (filename, blogFiles) => {\n  try {\n    console.log('Processing file:', filename);\n    const fileResponse = await fetch(`/blogs/${filename}`);\n    if (fileResponse.ok) {\n      const content = await fileResponse.text();\n      console.log(`Loaded content for ${filename}, length:`, content.length);\n      const {\n        data: frontmatter\n      } = parseFrontmatter(content);\n      console.log(`Frontmatter for ${filename}:`, frontmatter);\n      const blogPost = {\n        id: blogFiles.length + 1,\n        // Add ID for Home component\n        filename: filename.replace('.md', ''),\n        slug: filename.replace('.md', ''),\n        title: frontmatter.Title || filename.replace('.md', '').replace(/-/g, ' '),\n        description: frontmatter.Description || '',\n        author: frontmatter.Author || 'Unknown',\n        category: Array.isArray(frontmatter.Category) ? frontmatter.Category[0] : frontmatter.Category || 'General',\n        tags: frontmatter.Tags || [],\n        image: frontmatter.Image || 'portfolio_theory.gif',\n        excerpt: frontmatter.Excerpt || frontmatter.Description || '',\n        featured: frontmatter.Featured === 'true' || frontmatter.Featured === true,\n        status: frontmatter.Status || 'published',\n        estimatedReadingTime: frontmatter['Estimated Reading Time'] || '10 min',\n        // Ensure we have a date for sorting\n        date: frontmatter.date || frontmatter.Created || new Date().toISOString().split('T')[0]\n      };\n      console.log(`Created blog post object for ${filename}:`, blogPost);\n      blogFiles.push(blogPost);\n    } else {\n      console.warn(`Could not fetch ${filename}, status:`, fileResponse.status);\n    }\n  } catch (error) {\n    console.warn(`Could not load blog file ${filename}:`, error);\n  }\n};","map":{"version":3,"names":["marked","setOptions","breaks","gfm","parseFrontmatter","text","console","log","length","substring","lines","split","JSON","stringify","trim","data","content","frontmatterEnd","i","frontmatterLines","slice","join","frontmatter","currentKey","forEach","line","index","trimmedLine","startsWith","value","Array","isArray","push","includes","key","valueParts","endsWith","parse","map","item","parseMarkdown","markdownPath","response","fetch","ok","Error","status","markdownText","htmlContent","rawContent","error","getAllBlogFiles","blogFiles","html","parser","DOMParser","doc","parseFromString","links","querySelectorAll","mdMatches","match","filename","loadBlogFile","link","getAttribute","warn","knownFiles","sortedFiles","sort","a","b","Date","date","fileResponse","blogPost","id","replace","slug","title","Title","description","Description","author","Author","category","Category","tags","Tags","image","Image","excerpt","Excerpt","featured","Featured","Status","estimatedReadingTime","Created","toISOString"],"sources":["C:/Users/Soheil/Desktop/Codebase/GitHub/quant-blog/src/utils/markdownParser.js"],"sourcesContent":["import { marked } from 'marked';\r\n\r\n// Configure marked options\r\nmarked.setOptions({\r\n  breaks: true,\r\n  gfm: true\r\n});\r\n\r\n// Parse frontmatter from markdown content\r\nconst parseFrontmatter = (text) => {\r\n  console.log('parseFrontmatter called with text length:', text.length);\r\n  console.log('First 200 chars:', text.substring(0, 200));\r\n  \r\n  const lines = text.split('\\n');\r\n  console.log('Total lines:', lines.length);\r\n  console.log('First line:', JSON.stringify(lines[0]));\r\n  \r\n  if (lines[0].trim() !== '---') {\r\n    console.log('No frontmatter detected - first line is not ---');\r\n    return { data: {}, content: text };\r\n  }\r\n  \r\n  let frontmatterEnd = -1;\r\n  for (let i = 1; i < lines.length; i++) {\r\n    if (lines[i].trim() === '---') {\r\n      frontmatterEnd = i;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  console.log('Frontmatter end found at line:', frontmatterEnd);\r\n  \r\n  if (frontmatterEnd === -1) {\r\n    console.log('No closing --- found');\r\n    return { data: {}, content: text };\r\n  }\r\n  \r\n  const frontmatterLines = lines.slice(1, frontmatterEnd);\r\n  const content = lines.slice(frontmatterEnd + 1).join('\\n');\r\n  \r\n  console.log('Frontmatter lines:', frontmatterLines);\r\n  console.log('Content after frontmatter (first 200 chars):', content.substring(0, 200));\r\n  \r\n  const frontmatter = {};\r\n  let currentKey = null;\r\n  \r\n  frontmatterLines.forEach((line, index) => {\r\n    const trimmedLine = line.trim();\r\n    console.log(`Processing line ${index}: \"${line}\" (trimmed: \"${trimmedLine}\")`);\r\n    \r\n    if (trimmedLine.startsWith('-') && currentKey) {\r\n      // YAML array item\r\n      const value = trimmedLine.substring(1).trim();\r\n      console.log(`  Adding array item \"${value}\" to key \"${currentKey}\"`);\r\n      if (!Array.isArray(frontmatter[currentKey])) {\r\n        frontmatter[currentKey] = [];\r\n      }\r\n      frontmatter[currentKey].push(value);\r\n    } else if (trimmedLine.includes(':')) {\r\n      // Key-value pair\r\n      const [key, ...valueParts] = line.split(':');\r\n      const value = valueParts.join(':').trim();\r\n      currentKey = key.trim();\r\n      \r\n      console.log(`  Found key-value: \"${currentKey}\" = \"${value}\"`);\r\n      \r\n      if (value) {\r\n        // Handle JSON-style arrays [item1, item2]\r\n        if (value.startsWith('[') && value.endsWith(']')) {\r\n          try {\r\n            frontmatter[currentKey] = JSON.parse(value);\r\n            console.log(`    Parsed as JSON array:`, frontmatter[currentKey]);\r\n          } catch {\r\n            frontmatter[currentKey] = value.slice(1, -1).split(',').map(item => item.trim());\r\n            console.log(`    Parsed as simple array:`, frontmatter[currentKey]);\r\n          }\r\n        } \r\n        // Handle quoted strings\r\n        else if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\r\n          frontmatter[currentKey] = value.slice(1, -1);\r\n          console.log(`    Parsed as quoted string:`, frontmatter[currentKey]);\r\n        }\r\n        // Handle booleans\r\n        else if (value === 'true' || value === 'false') {\r\n          frontmatter[currentKey] = value === 'true';\r\n          console.log(`    Parsed as boolean:`, frontmatter[currentKey]);\r\n        }\r\n        // Handle regular strings\r\n        else {\r\n          frontmatter[currentKey] = value;\r\n          console.log(`    Parsed as string:`, frontmatter[currentKey]);\r\n        }\r\n      } else {\r\n        // Key without value - prepare for YAML array\r\n        frontmatter[currentKey] = [];\r\n        console.log(`    Initialized as empty array for YAML items`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  console.log('Final parsed frontmatter:', frontmatter);\r\n  console.log('Content length after parsing:', content.length);\r\n  \r\n  return { data: frontmatter, content };\r\n};\r\n\r\nexport const parseMarkdown = async (markdownPath) => {\r\n  try {\r\n    const response = await fetch(markdownPath);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\r\n    }\r\n    const markdownText = await response.text();\r\n    \r\n    // Parse frontmatter and content (content should already be stripped of frontmatter)\r\n    const { data: frontmatter, content } = parseFrontmatter(markdownText);\r\n    \r\n    console.log('parseMarkdown - Raw content length:', content.length);\r\n    console.log('parseMarkdown - Content preview:', content.substring(0, 200));\r\n    \r\n    // Convert markdown to HTML\r\n    const htmlContent = marked(content);\r\n    \r\n    return {\r\n      frontmatter,\r\n      content: htmlContent,\r\n      rawContent: content\r\n    };\r\n  } catch (error) {\r\n    console.error('Error parsing markdown:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Get all blog files from the /blogs directory\r\nexport const getAllBlogFiles = async () => {\r\n  try {\r\n    console.log('Starting blog discovery...');\r\n    \r\n    // First, try to get directory listing\r\n    let blogFiles = [];\r\n    \r\n    try {\r\n      const response = await fetch('/blogs');\r\n      if (response.ok) {\r\n        const html = await response.text();\r\n        console.log('Directory listing HTML length:', html.length);\r\n        \r\n        // Extract .md file names from directory listing HTML\r\n        const parser = new DOMParser();\r\n        const doc = parser.parseFromString(html, 'text/html');\r\n        \r\n        // Try multiple selectors to find .md files\r\n        let links = doc.querySelectorAll('a[href$=\".md\"]');\r\n        if (links.length === 0) {\r\n          // Fallback: look for any links containing .md\r\n          links = doc.querySelectorAll('a[href*=\".md\"]');\r\n        }\r\n        if (links.length === 0) {\r\n          // Another fallback: look in the HTML text for .md files\r\n          const mdMatches = html.match(/[\\w-]+\\.md/g);\r\n          if (mdMatches) {\r\n            console.log('Found .md files via regex:', mdMatches);\r\n            for (const filename of mdMatches) {\r\n              await loadBlogFile(filename, blogFiles);\r\n            }\r\n          }\r\n        } else {\r\n          console.log('Found .md links via querySelector:', links.length);\r\n          for (const link of links) {\r\n            const filename = link.getAttribute('href');\r\n            if (filename && filename.endsWith('.md')) {\r\n              await loadBlogFile(filename, blogFiles);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('Directory listing failed, trying fallback method:', error);\r\n    }\r\n    \r\n    // Fallback: if no files found via directory listing, try known files\r\n    if (blogFiles.length === 0) {\r\n      console.log('No files found via directory listing, trying known files...');\r\n      const knownFiles = [\r\n        'momentum-trading-strategies.md',\r\n        'portfolio-theory-optimization.md',\r\n        'breakout-trading-systems.md',\r\n        'rainbow-algorithm-analysis.md'\r\n      ];\r\n      \r\n      for (const filename of knownFiles) {\r\n        await loadBlogFile(filename, blogFiles);\r\n      }\r\n    }\r\n    \r\n    console.log('Total blog files processed:', blogFiles.length);\r\n    \r\n    // Sort by date (newest first)\r\n    const sortedFiles = blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\r\n    console.log('Sorted blog files:', sortedFiles);\r\n    \r\n    return sortedFiles;\r\n    \r\n  } catch (error) {\r\n    console.error('Error getting blog files:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n// Helper function to load a single blog file\r\nconst loadBlogFile = async (filename, blogFiles) => {\r\n  try {\r\n    console.log('Processing file:', filename);\r\n    \r\n    const fileResponse = await fetch(`/blogs/${filename}`);\r\n    if (fileResponse.ok) {\r\n      const content = await fileResponse.text();\r\n      console.log(`Loaded content for ${filename}, length:`, content.length);\r\n      \r\n      const { data: frontmatter } = parseFrontmatter(content);\r\n      console.log(`Frontmatter for ${filename}:`, frontmatter);\r\n      \r\n      const blogPost = {\r\n        id: blogFiles.length + 1, // Add ID for Home component\r\n        filename: filename.replace('.md', ''),\r\n        slug: filename.replace('.md', ''),\r\n        title: frontmatter.Title || filename.replace('.md', '').replace(/-/g, ' '),\r\n        description: frontmatter.Description || '',\r\n        author: frontmatter.Author || 'Unknown',\r\n        category: Array.isArray(frontmatter.Category) ? frontmatter.Category[0] : frontmatter.Category || 'General',\r\n        tags: frontmatter.Tags || [],\r\n        image: frontmatter.Image || 'portfolio_theory.gif',\r\n        excerpt: frontmatter.Excerpt || frontmatter.Description || '',\r\n        featured: frontmatter.Featured === 'true' || frontmatter.Featured === true,\r\n        status: frontmatter.Status || 'published',\r\n        estimatedReadingTime: frontmatter['Estimated Reading Time'] || '10 min',\r\n        // Ensure we have a date for sorting\r\n        date: frontmatter.date || frontmatter.Created || new Date().toISOString().split('T')[0]\r\n      };\r\n      \r\n      console.log(`Created blog post object for ${filename}:`, blogPost);\r\n      blogFiles.push(blogPost);\r\n    } else {\r\n      console.warn(`Could not fetch ${filename}, status:`, fileResponse.status);\r\n    }\r\n  } catch (error) {\r\n    console.warn(`Could not load blog file ${filename}:`, error);\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}