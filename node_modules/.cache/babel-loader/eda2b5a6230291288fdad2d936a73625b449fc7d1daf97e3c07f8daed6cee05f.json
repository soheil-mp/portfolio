{"ast":null,"code":"import { marked } from 'marked';\n\n// Configure marked options\nmarked.setOptions({\n  breaks: true,\n  gfm: true\n});\n\n// Parse frontmatter from markdown content\nconst parseFrontmatter = text => {\n  const lines = text.split('\\n');\n  if (lines[0] !== '---') {\n    return {\n      data: {},\n      content: text\n    };\n  }\n  let frontmatterEnd = -1;\n  for (let i = 1; i < lines.length; i++) {\n    if (lines[i] === '---') {\n      frontmatterEnd = i;\n      break;\n    }\n  }\n  if (frontmatterEnd === -1) {\n    return {\n      data: {},\n      content: text\n    };\n  }\n  const frontmatterLines = lines.slice(1, frontmatterEnd);\n  const content = lines.slice(frontmatterEnd + 1).join('\\n');\n  const frontmatter = {};\n  frontmatterLines.forEach(line => {\n    const [key, ...valueParts] = line.split(':');\n    if (key && valueParts.length > 0) {\n      const value = valueParts.join(':').trim();\n\n      // Handle arrays (for tags, categories, etc.)\n      if (value.startsWith('[') && value.endsWith(']')) {\n        try {\n          frontmatter[key.trim()] = JSON.parse(value);\n        } catch {\n          frontmatter[key.trim()] = value.slice(1, -1).split(',').map(item => item.trim());\n        }\n      } else {\n        frontmatter[key.trim()] = value;\n      }\n    }\n  });\n  return {\n    data: frontmatter,\n    content\n  };\n};\nexport const parseMarkdown = async markdownPath => {\n  try {\n    const response = await fetch(markdownPath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\n    }\n    const markdownText = await response.text();\n\n    // Parse frontmatter and content\n    const {\n      data: frontmatter,\n      content\n    } = parseFrontmatter(markdownText);\n\n    // Convert markdown to HTML\n    const htmlContent = marked(content);\n    return {\n      frontmatter,\n      content: htmlContent,\n      rawContent: content\n    };\n  } catch (error) {\n    console.error('Error parsing markdown:', error);\n    return null;\n  }\n};\n\n// Get all blog files from the /blogs directory\nexport const getAllBlogFiles = async () => {\n  try {\n    console.log('Starting blog discovery...');\n\n    // Get list of all files in the blogs directory\n    const response = await fetch('/blogs');\n    if (!response.ok) {\n      console.warn('Could not fetch blog directory listing, status:', response.status);\n      return [];\n    }\n    const html = await response.text();\n    console.log('Directory listing HTML length:', html.length);\n\n    // Extract .md file names from directory listing HTML\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, 'text/html');\n    const links = doc.querySelectorAll('a[href$=\".md\"]');\n    console.log('Found .md links:', links.length);\n    const blogFiles = [];\n    for (const link of links) {\n      const filename = link.getAttribute('href');\n      console.log('Processing file:', filename);\n      if (filename && filename.endsWith('.md')) {\n        try {\n          const fileResponse = await fetch(`/blogs/${filename}`);\n          if (fileResponse.ok) {\n            const content = await fileResponse.text();\n            console.log(`Loaded content for ${filename}, length:`, content.length);\n            const {\n              data: frontmatter\n            } = parseFrontmatter(content);\n            console.log(`Frontmatter for ${filename}:`, frontmatter);\n            const blogPost = {\n              filename: filename.replace('.md', ''),\n              slug: filename.replace('.md', ''),\n              title: frontmatter.Title || filename.replace('.md', '').replace(/-/g, ' '),\n              description: frontmatter.Description || '',\n              author: frontmatter.Author || 'Unknown',\n              category: frontmatter.Category || 'General',\n              tags: frontmatter.Tags || [],\n              image: frontmatter.Image || 'portfolio_theory.gif',\n              excerpt: frontmatter.Excerpt || frontmatter.Description || '',\n              featured: frontmatter.Featured === 'true' || frontmatter.Featured === true,\n              status: frontmatter.Status || 'published',\n              estimatedReadingTime: frontmatter['Estimated Reading Time'] || '10 min',\n              // Ensure we have a date for sorting\n              date: frontmatter.date || frontmatter.Created || new Date().toISOString().split('T')[0]\n            };\n            console.log(`Created blog post object for ${filename}:`, blogPost);\n            blogFiles.push(blogPost);\n          } else {\n            console.warn(`Could not fetch ${filename}, status:`, fileResponse.status);\n          }\n        } catch (error) {\n          console.warn(`Could not load blog file ${filename}:`, error);\n        }\n      }\n    }\n    console.log('Total blog files processed:', blogFiles.length);\n\n    // Sort by date (newest first)\n    const sortedFiles = blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\n    console.log('Sorted blog files:', sortedFiles);\n    return sortedFiles;\n  } catch (error) {\n    console.error('Error getting blog files:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["marked","setOptions","breaks","gfm","parseFrontmatter","text","lines","split","data","content","frontmatterEnd","i","length","frontmatterLines","slice","join","frontmatter","forEach","line","key","valueParts","value","trim","startsWith","endsWith","JSON","parse","map","item","parseMarkdown","markdownPath","response","fetch","ok","Error","status","markdownText","htmlContent","rawContent","error","console","getAllBlogFiles","log","warn","html","parser","DOMParser","doc","parseFromString","links","querySelectorAll","blogFiles","link","filename","getAttribute","fileResponse","blogPost","replace","slug","title","Title","description","Description","author","Author","category","Category","tags","Tags","image","Image","excerpt","Excerpt","featured","Featured","Status","estimatedReadingTime","date","Created","Date","toISOString","push","sortedFiles","sort","a","b"],"sources":["C:/Users/Soheil/Desktop/Codebase/GitHub/quant-blog/src/utils/markdownParser.js"],"sourcesContent":["import { marked } from 'marked';\r\n\r\n// Configure marked options\r\nmarked.setOptions({\r\n  breaks: true,\r\n  gfm: true\r\n});\r\n\r\n// Parse frontmatter from markdown content\r\nconst parseFrontmatter = (text) => {\r\n  const lines = text.split('\\n');\r\n  \r\n  if (lines[0] !== '---') {\r\n    return { data: {}, content: text };\r\n  }\r\n  \r\n  let frontmatterEnd = -1;\r\n  for (let i = 1; i < lines.length; i++) {\r\n    if (lines[i] === '---') {\r\n      frontmatterEnd = i;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  if (frontmatterEnd === -1) {\r\n    return { data: {}, content: text };\r\n  }\r\n  \r\n  const frontmatterLines = lines.slice(1, frontmatterEnd);\r\n  const content = lines.slice(frontmatterEnd + 1).join('\\n');\r\n  \r\n  const frontmatter = {};\r\n  frontmatterLines.forEach(line => {\r\n    const [key, ...valueParts] = line.split(':');\r\n    if (key && valueParts.length > 0) {\r\n      const value = valueParts.join(':').trim();\r\n      \r\n      // Handle arrays (for tags, categories, etc.)\r\n      if (value.startsWith('[') && value.endsWith(']')) {\r\n        try {\r\n          frontmatter[key.trim()] = JSON.parse(value);\r\n        } catch {\r\n          frontmatter[key.trim()] = value.slice(1, -1).split(',').map(item => item.trim());\r\n        }\r\n      } else {\r\n        frontmatter[key.trim()] = value;\r\n      }\r\n    }\r\n  });\r\n  \r\n  return { data: frontmatter, content };\r\n};\r\n\r\nexport const parseMarkdown = async (markdownPath) => {\r\n  try {\r\n    const response = await fetch(markdownPath);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\r\n    }\r\n    const markdownText = await response.text();\r\n    \r\n    // Parse frontmatter and content\r\n    const { data: frontmatter, content } = parseFrontmatter(markdownText);\r\n    \r\n    // Convert markdown to HTML\r\n    const htmlContent = marked(content);\r\n    \r\n    return {\r\n      frontmatter,\r\n      content: htmlContent,\r\n      rawContent: content\r\n    };\r\n  } catch (error) {\r\n    console.error('Error parsing markdown:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Get all blog files from the /blogs directory\r\nexport const getAllBlogFiles = async () => {\r\n  try {\r\n    console.log('Starting blog discovery...');\r\n    \r\n    // Get list of all files in the blogs directory\r\n    const response = await fetch('/blogs');\r\n    if (!response.ok) {\r\n      console.warn('Could not fetch blog directory listing, status:', response.status);\r\n      return [];\r\n    }\r\n    \r\n    const html = await response.text();\r\n    console.log('Directory listing HTML length:', html.length);\r\n    \r\n    // Extract .md file names from directory listing HTML\r\n    const parser = new DOMParser();\r\n    const doc = parser.parseFromString(html, 'text/html');\r\n    const links = doc.querySelectorAll('a[href$=\".md\"]');\r\n    \r\n    console.log('Found .md links:', links.length);\r\n    \r\n    const blogFiles = [];\r\n    \r\n    for (const link of links) {\r\n      const filename = link.getAttribute('href');\r\n      console.log('Processing file:', filename);\r\n      \r\n      if (filename && filename.endsWith('.md')) {\r\n        try {\r\n          const fileResponse = await fetch(`/blogs/${filename}`);\r\n          if (fileResponse.ok) {\r\n            const content = await fileResponse.text();\r\n            console.log(`Loaded content for ${filename}, length:`, content.length);\r\n            \r\n            const { data: frontmatter } = parseFrontmatter(content);\r\n            console.log(`Frontmatter for ${filename}:`, frontmatter);\r\n            \r\n            const blogPost = {\r\n              filename: filename.replace('.md', ''),\r\n              slug: filename.replace('.md', ''),\r\n              title: frontmatter.Title || filename.replace('.md', '').replace(/-/g, ' '),\r\n              description: frontmatter.Description || '',\r\n              author: frontmatter.Author || 'Unknown',\r\n              category: frontmatter.Category || 'General',\r\n              tags: frontmatter.Tags || [],\r\n              image: frontmatter.Image || 'portfolio_theory.gif',\r\n              excerpt: frontmatter.Excerpt || frontmatter.Description || '',\r\n              featured: frontmatter.Featured === 'true' || frontmatter.Featured === true,\r\n              status: frontmatter.Status || 'published',\r\n              estimatedReadingTime: frontmatter['Estimated Reading Time'] || '10 min',\r\n              // Ensure we have a date for sorting\r\n              date: frontmatter.date || frontmatter.Created || new Date().toISOString().split('T')[0]\r\n            };\r\n            \r\n            console.log(`Created blog post object for ${filename}:`, blogPost);\r\n            blogFiles.push(blogPost);\r\n          } else {\r\n            console.warn(`Could not fetch ${filename}, status:`, fileResponse.status);\r\n          }\r\n        } catch (error) {\r\n          console.warn(`Could not load blog file ${filename}:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.log('Total blog files processed:', blogFiles.length);\r\n    \r\n    // Sort by date (newest first)\r\n    const sortedFiles = blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\r\n    console.log('Sorted blog files:', sortedFiles);\r\n    \r\n    return sortedFiles;\r\n    \r\n  } catch (error) {\r\n    console.error('Error getting blog files:', error);\r\n    return [];\r\n  }\r\n}; "],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;;AAE/B;AACAA,MAAM,CAACC,UAAU,CAAC;EAChBC,MAAM,EAAE,IAAI;EACZC,GAAG,EAAE;AACP,CAAC,CAAC;;AAEF;AACA,MAAMC,gBAAgB,GAAIC,IAAI,IAAK;EACjC,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,IAAI,CAAC;EAE9B,IAAID,KAAK,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE;IACtB,OAAO;MAAEE,IAAI,EAAE,CAAC,CAAC;MAAEC,OAAO,EAAEJ;IAAK,CAAC;EACpC;EAEA,IAAIK,cAAc,GAAG,CAAC,CAAC;EACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,IAAIL,KAAK,CAACK,CAAC,CAAC,KAAK,KAAK,EAAE;MACtBD,cAAc,GAAGC,CAAC;MAClB;IACF;EACF;EAEA,IAAID,cAAc,KAAK,CAAC,CAAC,EAAE;IACzB,OAAO;MAAEF,IAAI,EAAE,CAAC,CAAC;MAAEC,OAAO,EAAEJ;IAAK,CAAC;EACpC;EAEA,MAAMQ,gBAAgB,GAAGP,KAAK,CAACQ,KAAK,CAAC,CAAC,EAAEJ,cAAc,CAAC;EACvD,MAAMD,OAAO,GAAGH,KAAK,CAACQ,KAAK,CAACJ,cAAc,GAAG,CAAC,CAAC,CAACK,IAAI,CAAC,IAAI,CAAC;EAE1D,MAAMC,WAAW,GAAG,CAAC,CAAC;EACtBH,gBAAgB,CAACI,OAAO,CAACC,IAAI,IAAI;IAC/B,MAAM,CAACC,GAAG,EAAE,GAAGC,UAAU,CAAC,GAAGF,IAAI,CAACX,KAAK,CAAC,GAAG,CAAC;IAC5C,IAAIY,GAAG,IAAIC,UAAU,CAACR,MAAM,GAAG,CAAC,EAAE;MAChC,MAAMS,KAAK,GAAGD,UAAU,CAACL,IAAI,CAAC,GAAG,CAAC,CAACO,IAAI,CAAC,CAAC;;MAEzC;MACA,IAAID,KAAK,CAACE,UAAU,CAAC,GAAG,CAAC,IAAIF,KAAK,CAACG,QAAQ,CAAC,GAAG,CAAC,EAAE;QAChD,IAAI;UACFR,WAAW,CAACG,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC,GAAGG,IAAI,CAACC,KAAK,CAACL,KAAK,CAAC;QAC7C,CAAC,CAAC,MAAM;UACNL,WAAW,CAACG,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC,GAAGD,KAAK,CAACP,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACP,KAAK,CAAC,GAAG,CAAC,CAACoB,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACN,IAAI,CAAC,CAAC,CAAC;QAClF;MACF,CAAC,MAAM;QACLN,WAAW,CAACG,GAAG,CAACG,IAAI,CAAC,CAAC,CAAC,GAAGD,KAAK;MACjC;IACF;EACF,CAAC,CAAC;EAEF,OAAO;IAAEb,IAAI,EAAEQ,WAAW;IAAEP;EAAQ,CAAC;AACvC,CAAC;AAED,OAAO,MAAMoB,aAAa,GAAG,MAAOC,YAAY,IAAK;EACnD,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAACF,YAAY,CAAC;IAC1C,IAAI,CAACC,QAAQ,CAACE,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,mBAAmBJ,YAAY,KAAKC,QAAQ,CAACI,MAAM,EAAE,CAAC;IACxE;IACA,MAAMC,YAAY,GAAG,MAAML,QAAQ,CAAC1B,IAAI,CAAC,CAAC;;IAE1C;IACA,MAAM;MAAEG,IAAI,EAAEQ,WAAW;MAAEP;IAAQ,CAAC,GAAGL,gBAAgB,CAACgC,YAAY,CAAC;;IAErE;IACA,MAAMC,WAAW,GAAGrC,MAAM,CAACS,OAAO,CAAC;IAEnC,OAAO;MACLO,WAAW;MACXP,OAAO,EAAE4B,WAAW;MACpBC,UAAU,EAAE7B;IACd,CAAC;EACH,CAAC,CAAC,OAAO8B,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAME,eAAe,GAAG,MAAAA,CAAA,KAAY;EACzC,IAAI;IACFD,OAAO,CAACE,GAAG,CAAC,4BAA4B,CAAC;;IAEzC;IACA,MAAMX,QAAQ,GAAG,MAAMC,KAAK,CAAC,QAAQ,CAAC;IACtC,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;MAChBO,OAAO,CAACG,IAAI,CAAC,iDAAiD,EAAEZ,QAAQ,CAACI,MAAM,CAAC;MAChF,OAAO,EAAE;IACX;IAEA,MAAMS,IAAI,GAAG,MAAMb,QAAQ,CAAC1B,IAAI,CAAC,CAAC;IAClCmC,OAAO,CAACE,GAAG,CAAC,gCAAgC,EAAEE,IAAI,CAAChC,MAAM,CAAC;;IAE1D;IACA,MAAMiC,MAAM,GAAG,IAAIC,SAAS,CAAC,CAAC;IAC9B,MAAMC,GAAG,GAAGF,MAAM,CAACG,eAAe,CAACJ,IAAI,EAAE,WAAW,CAAC;IACrD,MAAMK,KAAK,GAAGF,GAAG,CAACG,gBAAgB,CAAC,gBAAgB,CAAC;IAEpDV,OAAO,CAACE,GAAG,CAAC,kBAAkB,EAAEO,KAAK,CAACrC,MAAM,CAAC;IAE7C,MAAMuC,SAAS,GAAG,EAAE;IAEpB,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;MACxB,MAAMI,QAAQ,GAAGD,IAAI,CAACE,YAAY,CAAC,MAAM,CAAC;MAC1Cd,OAAO,CAACE,GAAG,CAAC,kBAAkB,EAAEW,QAAQ,CAAC;MAEzC,IAAIA,QAAQ,IAAIA,QAAQ,CAAC7B,QAAQ,CAAC,KAAK,CAAC,EAAE;QACxC,IAAI;UACF,MAAM+B,YAAY,GAAG,MAAMvB,KAAK,CAAC,UAAUqB,QAAQ,EAAE,CAAC;UACtD,IAAIE,YAAY,CAACtB,EAAE,EAAE;YACnB,MAAMxB,OAAO,GAAG,MAAM8C,YAAY,CAAClD,IAAI,CAAC,CAAC;YACzCmC,OAAO,CAACE,GAAG,CAAC,sBAAsBW,QAAQ,WAAW,EAAE5C,OAAO,CAACG,MAAM,CAAC;YAEtE,MAAM;cAAEJ,IAAI,EAAEQ;YAAY,CAAC,GAAGZ,gBAAgB,CAACK,OAAO,CAAC;YACvD+B,OAAO,CAACE,GAAG,CAAC,mBAAmBW,QAAQ,GAAG,EAAErC,WAAW,CAAC;YAExD,MAAMwC,QAAQ,GAAG;cACfH,QAAQ,EAAEA,QAAQ,CAACI,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;cACrCC,IAAI,EAAEL,QAAQ,CAACI,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;cACjCE,KAAK,EAAE3C,WAAW,CAAC4C,KAAK,IAAIP,QAAQ,CAACI,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC;cAC1EI,WAAW,EAAE7C,WAAW,CAAC8C,WAAW,IAAI,EAAE;cAC1CC,MAAM,EAAE/C,WAAW,CAACgD,MAAM,IAAI,SAAS;cACvCC,QAAQ,EAAEjD,WAAW,CAACkD,QAAQ,IAAI,SAAS;cAC3CC,IAAI,EAAEnD,WAAW,CAACoD,IAAI,IAAI,EAAE;cAC5BC,KAAK,EAAErD,WAAW,CAACsD,KAAK,IAAI,sBAAsB;cAClDC,OAAO,EAAEvD,WAAW,CAACwD,OAAO,IAAIxD,WAAW,CAAC8C,WAAW,IAAI,EAAE;cAC7DW,QAAQ,EAAEzD,WAAW,CAAC0D,QAAQ,KAAK,MAAM,IAAI1D,WAAW,CAAC0D,QAAQ,KAAK,IAAI;cAC1EvC,MAAM,EAAEnB,WAAW,CAAC2D,MAAM,IAAI,WAAW;cACzCC,oBAAoB,EAAE5D,WAAW,CAAC,wBAAwB,CAAC,IAAI,QAAQ;cACvE;cACA6D,IAAI,EAAE7D,WAAW,CAAC6D,IAAI,IAAI7D,WAAW,CAAC8D,OAAO,IAAI,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAACzE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YACxF,CAAC;YAEDiC,OAAO,CAACE,GAAG,CAAC,gCAAgCW,QAAQ,GAAG,EAAEG,QAAQ,CAAC;YAClEL,SAAS,CAAC8B,IAAI,CAACzB,QAAQ,CAAC;UAC1B,CAAC,MAAM;YACLhB,OAAO,CAACG,IAAI,CAAC,mBAAmBU,QAAQ,WAAW,EAAEE,YAAY,CAACpB,MAAM,CAAC;UAC3E;QACF,CAAC,CAAC,OAAOI,KAAK,EAAE;UACdC,OAAO,CAACG,IAAI,CAAC,4BAA4BU,QAAQ,GAAG,EAAEd,KAAK,CAAC;QAC9D;MACF;IACF;IAEAC,OAAO,CAACE,GAAG,CAAC,6BAA6B,EAAES,SAAS,CAACvC,MAAM,CAAC;;IAE5D;IACA,MAAMsE,WAAW,GAAG/B,SAAS,CAACgC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,IAAIN,IAAI,CAACM,CAAC,CAACR,IAAI,CAAC,GAAG,IAAIE,IAAI,CAACK,CAAC,CAACP,IAAI,CAAC,CAAC;IACjFrC,OAAO,CAACE,GAAG,CAAC,oBAAoB,EAAEwC,WAAW,CAAC;IAE9C,OAAOA,WAAW;EAEpB,CAAC,CAAC,OAAO3C,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,OAAO,EAAE;EACX;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}