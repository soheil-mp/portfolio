{"ast":null,"code":"import { marked } from 'marked';\n\n// Configure marked options\nmarked.setOptions({\n  breaks: true,\n  gfm: true\n});\n\n// Simple frontmatter parser\nconst parseFrontmatter = text => {\n  const match = text.match(/^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/);\n  if (!match) {\n    return {\n      data: {},\n      content: text\n    };\n  }\n  const frontmatterText = match[1];\n  const content = match[2];\n  const data = {};\n  let currentKey = null;\n\n  // Parse YAML-like frontmatter\n  frontmatterText.split('\\n').forEach(line => {\n    const trimmedLine = line.trim();\n    if (trimmedLine && trimmedLine.includes(':') && !trimmedLine.startsWith('-')) {\n      // Key-value pair\n      const [key, ...valueParts] = trimmedLine.split(':');\n      const value = valueParts.join(':').trim().replace(/^[\"']|[\"']$/g, '');\n      currentKey = key.trim();\n      if (value) {\n        data[currentKey] = value;\n      } else {\n        data[currentKey] = [];\n      }\n    } else if (trimmedLine.startsWith('-') && currentKey) {\n      // Array item\n      const value = trimmedLine.substring(1).trim();\n      if (!Array.isArray(data[currentKey])) {\n        data[currentKey] = [];\n      }\n      data[currentKey].push(value);\n    }\n  });\n  return {\n    data,\n    content\n  };\n};\n\n// Auto-discover markdown files by trying common naming patterns\nconst discoverMarkdownFiles = async () => {\n  const commonSlugs = ['momentum-trading-strategies', 'portfolio-theory-optimization', 'breakout-trading-systems', 'rainbow-algorithm-analysis',\n  // Add more potential file names here as you create them\n  'machine-learning-trading', 'risk-management', 'algorithmic-trading', 'quantitative-strategies', 'market-microstructure', 'derivatives-pricing', 'portfolio-construction', 'backtesting-strategies', 'high-frequency-trading', 'options-strategies'];\n  const validSlugs = [];\n  for (const slug of commonSlugs) {\n    try {\n      const response = await fetch(`/blogs/${slug}.md`);\n      if (response.ok) {\n        validSlugs.push(slug);\n      }\n    } catch (error) {\n      // File doesn't exist, skip it\n      continue;\n    }\n  }\n  return validSlugs;\n};\nexport const parseMarkdown = async markdownPath => {\n  try {\n    const response = await fetch(markdownPath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\n    }\n    const markdownText = await response.text();\n\n    // Parse frontmatter and content\n    const {\n      data: frontmatter,\n      content\n    } = parseFrontmatter(markdownText);\n\n    // Convert markdown to HTML\n    const htmlContent = marked(content);\n    return {\n      frontmatter,\n      content: htmlContent,\n      rawContent: content\n    };\n  } catch (error) {\n    console.error('Error parsing markdown:', error);\n    return null;\n  }\n};\nexport const getAllBlogSlugs = async () => {\n  return await discoverMarkdownFiles();\n};\n\n// Generate metadata from frontmatter and filename\nconst generateMetadataFromFrontmatter = (slug, frontmatter, index) => {\n  // Create a slug-based title if none provided\n  const defaultTitle = slug.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');\n  return {\n    id: index + 1,\n    title: frontmatter.Title || defaultTitle,\n    slug: slug,\n    description: frontmatter.Description || `Explore ${defaultTitle.toLowerCase()} and their applications in quantitative investment analysis.`,\n    author: frontmatter.Author || \"Soheil Mohammadpour\",\n    date: frontmatter.Created || new Date().toISOString().split('T')[0],\n    category: Array.isArray(frontmatter.Category) ? frontmatter.Category[0] : frontmatter.Category || \"Quantitative Analysis\",\n    tags: frontmatter.Tags || [slug.split('-')[0], \"trading\", \"quantitative\"],\n    image: frontmatter.Image || \"portfolio_theory.gif\",\n    // Default image\n    excerpt: frontmatter.Excerpt || frontmatter.Description || `Learn about ${defaultTitle.toLowerCase()} and how to implement them in your quantitative trading strategies.`,\n    featured: frontmatter.Featured === 'true' || frontmatter.Featured === true || false,\n    status: frontmatter.Status || \"published\",\n    estimatedReadingTime: frontmatter['Estimated Reading Time'] || \"10 minutes\"\n  };\n};\nexport const getBlogMetadata = async slug => {\n  try {\n    const markdownPath = `/blogs/${slug}.md`;\n    const response = await fetch(markdownPath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\n    }\n    const markdownText = await response.text();\n\n    // Parse frontmatter\n    const {\n      data: frontmatter\n    } = parseFrontmatter(markdownText);\n\n    // Generate metadata from frontmatter\n    return generateMetadataFromFrontmatter(slug, frontmatter, 0);\n  } catch (error) {\n    console.error('Error reading markdown frontmatter for', slug, ':', error);\n    return null;\n  }\n};\n\n// Get all blog posts with metadata\nexport const getAllBlogPosts = async () => {\n  try {\n    const slugs = await getAllBlogSlugs();\n    const posts = await Promise.all(slugs.map(async (slug, index) => {\n      try {\n        const markdownPath = `/blogs/${slug}.md`;\n        const response = await fetch(markdownPath);\n        if (!response.ok) return null;\n        const markdownText = await response.text();\n        const {\n          data: frontmatter\n        } = parseFrontmatter(markdownText);\n        return generateMetadataFromFrontmatter(slug, frontmatter, index);\n      } catch (error) {\n        console.error(`Error loading ${slug}:`, error);\n        return null;\n      }\n    }));\n    return posts.filter(post => post !== null);\n  } catch (error) {\n    console.error('Error loading all blog posts:', error);\n    return [];\n  }\n};\n\n// Get all blog files from the /blogs directory\nexport const getAllBlogFiles = async () => {\n  try {\n    // Get list of all files in the blogs directory\n    const response = await fetch('/blogs');\n    if (!response.ok) {\n      console.warn('Could not fetch blog directory listing');\n      return [];\n    }\n    const html = await response.text();\n\n    // Extract .md file names from directory listing HTML\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, 'text/html');\n    const links = doc.querySelectorAll('a[href$=\".md\"]');\n    const blogFiles = [];\n    for (const link of links) {\n      const filename = link.getAttribute('href');\n      if (filename && filename.endsWith('.md')) {\n        try {\n          const fileResponse = await fetch(`/blogs/${filename}`);\n          if (fileResponse.ok) {\n            const content = await fileResponse.text();\n            const {\n              frontmatter\n            } = parseFrontmatter(content);\n            blogFiles.push({\n              filename: filename.replace('.md', ''),\n              ...frontmatter,\n              // Ensure we have a date for sorting\n              date: frontmatter.date || new Date().toISOString().split('T')[0]\n            });\n          }\n        } catch (error) {\n          console.warn(`Could not load blog file ${filename}:`, error);\n        }\n      }\n    }\n\n    // Sort by date (newest first)\n    return blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\n  } catch (error) {\n    console.error('Error getting blog files:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["marked","setOptions","breaks","gfm","parseFrontmatter","text","match","data","content","frontmatterText","currentKey","split","forEach","line","trimmedLine","trim","includes","startsWith","key","valueParts","value","join","replace","substring","Array","isArray","push","discoverMarkdownFiles","commonSlugs","validSlugs","slug","response","fetch","ok","error","parseMarkdown","markdownPath","Error","status","markdownText","frontmatter","htmlContent","rawContent","console","getAllBlogSlugs","generateMetadataFromFrontmatter","index","defaultTitle","map","word","charAt","toUpperCase","slice","id","title","Title","description","Description","toLowerCase","author","Author","date","Created","Date","toISOString","category","Category","tags","Tags","image","Image","excerpt","Excerpt","featured","Featured","Status","estimatedReadingTime","getBlogMetadata","getAllBlogPosts","slugs","posts","Promise","all","filter","post","getAllBlogFiles","warn","html","parser","DOMParser","doc","parseFromString","links","querySelectorAll","blogFiles","link","filename","getAttribute","endsWith","fileResponse","sort","a","b"],"sources":["C:/Users/Soheil/Desktop/Codebase/GitHub/quant-blog/src/utils/markdownParser.js"],"sourcesContent":["import { marked } from 'marked';\r\n\r\n// Configure marked options\r\nmarked.setOptions({\r\n  breaks: true,\r\n  gfm: true,\r\n});\r\n\r\n// Simple frontmatter parser\r\nconst parseFrontmatter = (text) => {\r\n  const match = text.match(/^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n([\\s\\S]*)$/);\r\n  if (!match) {\r\n    return { data: {}, content: text };\r\n  }\r\n\r\n  const frontmatterText = match[1];\r\n  const content = match[2];\r\n  const data = {};\r\n  let currentKey = null;\r\n\r\n  // Parse YAML-like frontmatter\r\n  frontmatterText.split('\\n').forEach(line => {\r\n    const trimmedLine = line.trim();\r\n    if (trimmedLine && trimmedLine.includes(':') && !trimmedLine.startsWith('-')) {\r\n      // Key-value pair\r\n      const [key, ...valueParts] = trimmedLine.split(':');\r\n      const value = valueParts.join(':').trim().replace(/^[\"']|[\"']$/g, '');\r\n      currentKey = key.trim();\r\n      if (value) {\r\n        data[currentKey] = value;\r\n      } else {\r\n        data[currentKey] = [];\r\n      }\r\n    } else if (trimmedLine.startsWith('-') && currentKey) {\r\n      // Array item\r\n      const value = trimmedLine.substring(1).trim();\r\n      if (!Array.isArray(data[currentKey])) {\r\n        data[currentKey] = [];\r\n      }\r\n      data[currentKey].push(value);\r\n    }\r\n  });\r\n\r\n  return { data, content };\r\n};\r\n\r\n// Auto-discover markdown files by trying common naming patterns\r\nconst discoverMarkdownFiles = async () => {\r\n  const commonSlugs = [\r\n    'momentum-trading-strategies',\r\n    'portfolio-theory-optimization',\r\n    'breakout-trading-systems',\r\n    'rainbow-algorithm-analysis',\r\n    // Add more potential file names here as you create them\r\n    'machine-learning-trading',\r\n    'risk-management',\r\n    'algorithmic-trading',\r\n    'quantitative-strategies',\r\n    'market-microstructure',\r\n    'derivatives-pricing',\r\n    'portfolio-construction',\r\n    'backtesting-strategies',\r\n    'high-frequency-trading',\r\n    'options-strategies'\r\n  ];\r\n\r\n  const validSlugs = [];\r\n  \r\n  for (const slug of commonSlugs) {\r\n    try {\r\n      const response = await fetch(`/blogs/${slug}.md`);\r\n      if (response.ok) {\r\n        validSlugs.push(slug);\r\n      }\r\n    } catch (error) {\r\n      // File doesn't exist, skip it\r\n      continue;\r\n    }\r\n  }\r\n  \r\n  return validSlugs;\r\n};\r\n\r\nexport const parseMarkdown = async (markdownPath) => {\r\n  try {\r\n    const response = await fetch(markdownPath);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\r\n    }\r\n    const markdownText = await response.text();\r\n    \r\n    // Parse frontmatter and content\r\n    const { data: frontmatter, content } = parseFrontmatter(markdownText);\r\n    \r\n    // Convert markdown to HTML\r\n    const htmlContent = marked(content);\r\n    \r\n    return {\r\n      frontmatter,\r\n      content: htmlContent,\r\n      rawContent: content\r\n    };\r\n  } catch (error) {\r\n    console.error('Error parsing markdown:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getAllBlogSlugs = async () => {\r\n  return await discoverMarkdownFiles();\r\n};\r\n\r\n// Generate metadata from frontmatter and filename\r\nconst generateMetadataFromFrontmatter = (slug, frontmatter, index) => {\r\n  // Create a slug-based title if none provided\r\n  const defaultTitle = slug\r\n    .split('-')\r\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1))\r\n    .join(' ');\r\n\r\n  return {\r\n    id: index + 1,\r\n    title: frontmatter.Title || defaultTitle,\r\n    slug: slug,\r\n    description: frontmatter.Description || `Explore ${defaultTitle.toLowerCase()} and their applications in quantitative investment analysis.`,\r\n    author: frontmatter.Author || \"Soheil Mohammadpour\",\r\n    date: frontmatter.Created || new Date().toISOString().split('T')[0],\r\n    category: Array.isArray(frontmatter.Category) ? frontmatter.Category[0] : frontmatter.Category || \"Quantitative Analysis\",\r\n    tags: frontmatter.Tags || [slug.split('-')[0], \"trading\", \"quantitative\"],\r\n    image: frontmatter.Image || \"portfolio_theory.gif\", // Default image\r\n    excerpt: frontmatter.Excerpt || frontmatter.Description || `Learn about ${defaultTitle.toLowerCase()} and how to implement them in your quantitative trading strategies.`,\r\n    featured: frontmatter.Featured === 'true' || frontmatter.Featured === true || false,\r\n    status: frontmatter.Status || \"published\",\r\n    estimatedReadingTime: frontmatter['Estimated Reading Time'] || \"10 minutes\"\r\n  };\r\n};\r\n\r\nexport const getBlogMetadata = async (slug) => {\r\n  try {\r\n    const markdownPath = `/blogs/${slug}.md`;\r\n    const response = await fetch(markdownPath);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch ${markdownPath}: ${response.status}`);\r\n    }\r\n    const markdownText = await response.text();\r\n    \r\n    // Parse frontmatter\r\n    const { data: frontmatter } = parseFrontmatter(markdownText);\r\n    \r\n    // Generate metadata from frontmatter\r\n    return generateMetadataFromFrontmatter(slug, frontmatter, 0);\r\n  } catch (error) {\r\n    console.error('Error reading markdown frontmatter for', slug, ':', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Get all blog posts with metadata\r\nexport const getAllBlogPosts = async () => {\r\n  try {\r\n    const slugs = await getAllBlogSlugs();\r\n    const posts = await Promise.all(\r\n      slugs.map(async (slug, index) => {\r\n        try {\r\n          const markdownPath = `/blogs/${slug}.md`;\r\n          const response = await fetch(markdownPath);\r\n          if (!response.ok) return null;\r\n          \r\n          const markdownText = await response.text();\r\n          const { data: frontmatter } = parseFrontmatter(markdownText);\r\n          \r\n          return generateMetadataFromFrontmatter(slug, frontmatter, index);\r\n        } catch (error) {\r\n          console.error(`Error loading ${slug}:`, error);\r\n          return null;\r\n        }\r\n      })\r\n    );\r\n    \r\n    return posts.filter(post => post !== null);\r\n  } catch (error) {\r\n    console.error('Error loading all blog posts:', error);\r\n    return [];\r\n  }\r\n}; \r\n\r\n// Get all blog files from the /blogs directory\r\nexport const getAllBlogFiles = async () => {\r\n  try {\r\n    // Get list of all files in the blogs directory\r\n    const response = await fetch('/blogs');\r\n    if (!response.ok) {\r\n      console.warn('Could not fetch blog directory listing');\r\n      return [];\r\n    }\r\n    \r\n    const html = await response.text();\r\n    \r\n    // Extract .md file names from directory listing HTML\r\n    const parser = new DOMParser();\r\n    const doc = parser.parseFromString(html, 'text/html');\r\n    const links = doc.querySelectorAll('a[href$=\".md\"]');\r\n    \r\n    const blogFiles = [];\r\n    \r\n    for (const link of links) {\r\n      const filename = link.getAttribute('href');\r\n      if (filename && filename.endsWith('.md')) {\r\n        try {\r\n          const fileResponse = await fetch(`/blogs/${filename}`);\r\n          if (fileResponse.ok) {\r\n            const content = await fileResponse.text();\r\n            const { frontmatter } = parseFrontmatter(content);\r\n            \r\n            blogFiles.push({\r\n              filename: filename.replace('.md', ''),\r\n              ...frontmatter,\r\n              // Ensure we have a date for sorting\r\n              date: frontmatter.date || new Date().toISOString().split('T')[0]\r\n            });\r\n          }\r\n        } catch (error) {\r\n          console.warn(`Could not load blog file ${filename}:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Sort by date (newest first)\r\n    return blogFiles.sort((a, b) => new Date(b.date) - new Date(a.date));\r\n    \r\n  } catch (error) {\r\n    console.error('Error getting blog files:', error);\r\n    return [];\r\n  }\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}